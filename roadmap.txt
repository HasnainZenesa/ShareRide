0) Product foundations (1–2 days)

Define & lock:

Target users: Passenger, Rider, Admin.

Regions, currencies (PKR), languages (en/ur).

Core business rules:

Riders pay monthly subscription to be discoverable / go online.

Passenger sees riders nearby only (within rider’s configured radius & platform cap).

Chat/Call buttons hidden until passenger has active subscription.

Risk & compliance: KYC for riders, basic privacy policy & TOS.

Deliverables: PRD (problem, users, flows), success metrics, glossary.

1) Architecture & stack (2–3 days)

High-level design:

Mobile app (React Native) with role-aware navigation (Passenger/Rider).

Backend services (REST + WebSocket).

DB: PostgreSQL + PostGIS (geo), Redis (geo-cache, queues, sessions).

Infra: Docker Compose (dev), later EAS / CI pipelines.

Observability: Sentry (errors), basic logging, health checks.

Deliverables: System architecture diagram, sequence diagrams for 3 flows:

Rider application → Admin approval

Passenger subscription gating (unlock chat/call)

Trip request → match → accept → complete

2) Data model & contracts (2–3 days)

Entities (first pass):

users (role: passenger/rider/admin, status)

riders (kyc_status, home_location, radius_km, is_online)

subscriptions (user_id or rider_id? — you: passenger subscription gates chat/call; riders also pay monthly plan to go online → keep both or separate plans)

trips (pickup, dropoff, status, fare)

rider_locations (current coords)

payouts, payment_methods, attachments (KYC docs)

Geo rules:

Use PostGIS for storage + queries; Redis GEO for fast candidate shortlist.

Distance thresholds: platform cap (e.g., 8–10km) ∩ rider’s radius_km.

API surface (names only, no code):

Auth: /auth/otp/request, /auth/otp/verify, /auth/refresh

Admin: /admin/riders/pending, /admin/riders/:id/approve|reject, /admin/stats/overview

Riders: /riders/me, /riders/apply, /riders/online|offline, /riders/location

Subs: /subs/passenger/start|status, /subs/rider/start|status

Trips: /trips/quote, /trips, /trips/:id/cancel, /trips/:id

Realtime (WS): rides:search, rides:offer, rides:accept/reject, rides:status:*

Chat: /chat/token (server issues room/token post-subscription check) or via WS namespace

Deliverables: ERD, endpoint list, request/response JSON examples in a spec doc.

3) Environment setup (2–3 days)

Docker Compose: Postgres (with PostGIS), Redis, API stub, Worker stub.

Secrets strategy (.env templates, do not commit keys).

Health endpoints + smoke tests.

Basic migrations (init tables) and admin bootstrap (first admin user).

Deliverables: Running local stack + README with start commands, env setup guide.

4) Admin foundations (1–1.5 weeks)

Goal: Admin can see everything and approve riders.

Admin auth (email+password or OTP for now).

Dashboard metrics: total users, riders, pending applications, active subscriptions, daily rides.

Rider approval queue: list → details → approve / reject (with reason).

Config screen: platform max_search_radius, pricing base, payouts cycle.

Audit logging for admin actions.

Deliverables: Admin flow spec, dashboard wireframes, metrics definitions, role middleware rules.

5) Rider onboarding & subscription (1.5–2 weeks)

Rider flow:

Signup → Apply as Rider → upload docs → set home_location + radius_km.

State machine: draft → submitted → under_review → approved/rejected.

Post-approval: must have active monthly subscription to toggle Online.

Payments: create product/price (monthly), start subscription, webhook to update subscriptions table.

Online/Offline: when Online, background location updates (every X sec) to WS or REST; visibility only if subscription active.

Deliverables: Rider application screens (spec), admin review SOP, subscription logic doc, state machine chart.

6) Passenger subscription gate (1 week)

Business rule: Chat/Call options appear only if passenger has active subscription.

Subscription purchase flow for passengers.

After success: toggle UI flags to show Chat & Call on rider cards and during an active trip.

Server-side guard: chat/call token/room issued only if active passenger subscription.

Deliverables: UX states (before/after purchase), backend gating rules, unit tests for gates.

7) Nearby search & matching (2 weeks)

Phase A: Nearby discovery

Passenger enters pickup → server returns nearby riders (top N by distance/ETA).

Use Redis GEO for quick shortlist; verify with PostGIS + ranking (distance + rating + acceptance rate).

Phase B: Offer & acceptance

Start trip: quote/price; create trip in created state.

Server sends offer to first K riders (WebSocket).

First accept within timeout wins; others auto-rejected; trip becomes accepted.

Phase C: Live updates

Status transitions: arriving → in_progress → completed/canceled.

Location stream (rider → passenger live map).

Notifications: offer, accepted, arriving, complete.

Deliverables: Matching algorithm spec, timeouts & retries table, message contracts for WS.

8) Payments & payouts (2 weeks)

Passenger payments

Pre-auth (optional) on trip create; capture on completed.

Refund flows on cancel/driver no-show.

Rider payouts

Weekly/bi-weekly aggregation of completed trips → payout batch → transfer via gateway/bank file → mark paid.

Statements (downloadable invoice/receipt).

Deliverables: Payment sequence diagrams, payout policy doc, edge cases matrix (declines, reversals).

9) Chat & Call (1–1.5 weeks)

Choose provider: Twilio (programmable chat/voice) or any RTC service.

Access control: server issues room/token only if hasActivePassengerSubscription == true and there’s an active trip between the two parties (or pre-trip window).

Push notifications for new message / incoming call.

Data retention & abuse controls (report/block).

Deliverables: ACL matrix, abuse/reporting SOP, retention policy.

10) App polish & reliability (2 weeks)

Error states, offline handling, retry policies.

Permissions UX (location, notifications, microphone for call).

Accessibility & localization (EN/UR).

Analytics: funnels (search→offer→accept→start→complete), subscription conversions.

Sentry integration, crash thresholds, performance budgets.

Deliverables: UX checklist, analytics events catalog, SLOs (latency, availability).

11) Security & compliance (ongoing, formal review in week 10–11)

JWT + refresh rotation; per-device session tracking.

RBAC: admin vs rider vs passenger routes.

Rate limits (OTP, search, chat).

Validate & sanitize inputs (Zod/JOI).

Protect PII (encryption at rest for sensitive fields), presigned URLs for doc access.

Audit logs for all admin & financial actions.

Backups & restoration drills (DB/Redis snapshots).

Deliverables: Threat model, rate limit table, incident runbook, backup SOP.

12) Testing & release plan (last 1–2 weeks of MVP)

Test layers: unit (domain), integration (API+DB), e2e (happy paths), load test for matching.

Device matrix: low/mid/high Android; some iOS if possible.

Go/No-Go checklist: auth, rider approval, nearby, subscription gates, payments capture/refund, chat/call gate.

Staging → pilot cohort (20–50 users/riders) → collect feedback → fix → v1.

Deliverables: Test plan, pilot feedback doc, release notes, rollback plan.

Day-to-day execution (agile rhythm)

Sprints: 1 week.

Backlog epics:

Auth & Admin

Rider onboarding & approvals

Subscriptions (passenger & rider)

Nearby & Matching

Trip lifecycle

Payments & Payouts

Chat & Call

Observability & Security

Each story has: acceptance criteria, API contract (if any), UI states, test cases, analytics events.

Metrics (define early)

Activation: % riders approved, time to approval.

Matching: time to first offer, offer acceptance rate, cancel rate.

Reliability: WS disconnects, location lag, 95p API latency.

Monetization: passenger subscription conversion, rider subscription renewal, ARPU.

Quality: average rating, support tickets per 100 trips.

Risks & mitigations

Location accuracy: use fused location + min accuracy filter; smooth with last N points.

Sparse supply: increase radius stepwise; queue mechanism & retry intervals.

Payment disputes: clear refund rules, strong receipts, support tooling.

Abuse in chat/call: report/block, limited windows, server-side recording metadata (if policy allows).

Scaling: separate WS service, use Redis pub/sub; shard geo keys by city.

What you should do next (actionable)

Freeze business rules (exact gates for chat/call & subscription types).

Approve architecture diagram + ERD + endpoint list (no code yet).

Spin up dev environment (Docker Compose) and verify health endpoints.

Start Admin + Rider onboarding epics first (approval flow is your platform gate).

In parallel, draft subscription flows (both passenger & rider).

Only then move to nearby + matching and trip lifecycle.

Chat/Call last (after gating & trip lifecycle is stable).

If you want, I can turn this into a Jira-ready backlog with epics → stories → acceptance criteria (still no code) and a weekly timeline.